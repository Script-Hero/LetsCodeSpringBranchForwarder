{"ast":null,"code":"// Copyright 2016-2018 AJ ONeal. All rights reserved\n// https://git.coolaj86.com/coolaj86/asn1-parser.js\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n;\n\n(function (exports) {\n  'use strict';\n\n  if (!exports.ASN1) {\n    exports.ASN1 = {};\n  }\n\n  if (!exports.Enc) {\n    exports.Enc = {};\n  }\n\n  if (!exports.PEM) {\n    exports.PEM = {};\n  }\n\n  var ASN1 = exports.ASN1;\n  var Enc = exports.Enc;\n  var PEM = exports.PEM; //\n  // Parser\n  //\n  // Although I've only seen 9 max in https certificates themselves,\n  // but each domain list could have up to 100\n\n  ASN1.ELOOPN = 102;\n  ASN1.ELOOP = \"uASN1.js Error: iterated over \" + ASN1.ELOOPN + \"+ elements (probably a malformed file)\"; // I've seen https certificates go 29 deep\n\n  ASN1.EDEEPN = 60;\n  ASN1.EDEEP = \"uASN1.js Error: element nested \" + ASN1.EDEEPN + \"+ layers deep (probably a malformed file)\"; // Container Types are Sequence 0x30, Container Array? (0xA0, 0xA1)\n  // Value Types are Boolean 0x01, Integer 0x02, Null 0x05, Object ID 0x06, String 0x0C, 0x16, 0x13, 0x1e Value Array? (0x82)\n  // Bit String (0x03) and Octet String (0x04) may be values or containers\n  // Sometimes Bit String is used as a container (RSA Pub Spki)\n\n  ASN1.CTYPES = [0x30, 0x31, 0xa0, 0xa1];\n  ASN1.VTYPES = [0x01, 0x02, 0x05, 0x06, 0x0c, 0x82];\n\n  ASN1.parse = function parseAsn1Helper(buf) {\n    //var ws = '  ';\n    function parseAsn1(buf, depth, eager) {\n      if (depth.length >= ASN1.EDEEPN) {\n        throw new Error(ASN1.EDEEP);\n      }\n\n      var index = 2; // we know, at minimum, data starts after type (0) and lengthSize (1)\n\n      var asn1 = {\n        type: buf[0],\n        lengthSize: 0,\n        length: buf[1]\n      };\n      var child;\n      var iters = 0;\n      var adjust = 0;\n      var adjustedLen; // Determine how many bytes the length uses, and what it is\n\n      if (0x80 & asn1.length) {\n        asn1.lengthSize = 0x7f & asn1.length; // I think that buf->hex->int solves the problem of Endianness... not sure\n\n        asn1.length = parseInt(Enc.bufToHex(buf.slice(index, index + asn1.lengthSize)), 16);\n        index += asn1.lengthSize;\n      } // High-order bit Integers have a leading 0x00 to signify that they are positive.\n      // Bit Streams use the first byte to signify padding, which x.509 doesn't use.\n\n\n      if (0x00 === buf[index] && (0x02 === asn1.type || 0x03 === asn1.type)) {\n        // However, 0x00 on its own is a valid number\n        if (asn1.length > 1) {\n          index += 1;\n          adjust = -1;\n        }\n      }\n\n      adjustedLen = asn1.length + adjust; //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n\n      function parseChildren(eager) {\n        asn1.children = []; //console.warn('1 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', 0);\n\n        while (iters < ASN1.ELOOPN && index < 2 + asn1.length + asn1.lengthSize) {\n          iters += 1;\n          depth.length += 1;\n          child = parseAsn1(buf.slice(index, index + adjustedLen), depth, eager);\n          depth.length -= 1; // The numbers don't match up exactly and I don't remember why...\n          // probably something with adjustedLen or some such, but the tests pass\n\n          index += 2 + child.lengthSize + child.length; //console.warn('2 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', (2 + child.lengthSize + child.length));\n\n          if (index > 2 + asn1.lengthSize + asn1.length) {\n            if (!eager) {\n              console.error(JSON.stringify(asn1, ASN1._replacer, 2));\n            }\n\n            throw new Error(\"Parse error: child value length (\" + child.length + \") is greater than remaining parent length (\" + (asn1.length - index) + \" = \" + asn1.length + \" - \" + index + \")\");\n          }\n\n          asn1.children.push(child); //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n        }\n\n        if (index !== 2 + asn1.lengthSize + asn1.length) {\n          //console.warn('index:', index, 'length:', (2 + asn1.lengthSize + asn1.length));\n          throw new Error(\"premature end-of-file\");\n        }\n\n        if (iters >= ASN1.ELOOPN) {\n          throw new Error(ASN1.ELOOP);\n        }\n\n        delete asn1.value;\n        return asn1;\n      } // Recurse into types that are _always_ containers\n\n\n      if (-1 !== ASN1.CTYPES.indexOf(asn1.type)) {\n        return parseChildren(eager);\n      } // Return types that are _always_ values\n\n\n      asn1.value = buf.slice(index, index + adjustedLen);\n\n      if (-1 !== ASN1.VTYPES.indexOf(asn1.type)) {\n        return asn1;\n      } // For ambigious / unknown types, recurse and return on failure\n      // (and return child array size to zero)\n\n\n      try {\n        return parseChildren(true);\n      } catch (e) {\n        asn1.children.length = 0;\n        return asn1;\n      }\n    }\n\n    var asn1 = parseAsn1(buf, []);\n    var len = buf.byteLength || buf.length;\n\n    if (len !== 2 + asn1.lengthSize + asn1.length) {\n      throw new Error(\"Length of buffer does not match length of ASN.1 sequence.\");\n    }\n\n    return asn1;\n  };\n\n  ASN1._replacer = function (k, v) {\n    if ('type' === k) {\n      return '0x' + Enc.numToHex(v);\n    }\n\n    if (v && 'value' === k) {\n      return '0x' + Enc.bufToHex(v.data || v);\n    }\n\n    return v;\n  }; // don't replace the full parseBlock, if it exists\n\n\n  PEM.parseBlock = PEM.parseBlock || function (str) {\n    var b64 = str.split(/\\n/).filter(function (line) {\n      return !/-----/.test(line);\n    }).join('');\n    var der = Enc.base64ToBuf(b64);\n    return {\n      bytes: der\n    };\n  };\n\n  Enc.base64ToBuf = function (b64) {\n    return Buffer.from(b64, 'base64');\n  };\n\n  Enc.binToBuf = function (bin) {\n    return Buffer.from(bin, 'binary');\n  };\n\n  Enc.bufToHex = function (u8) {\n    return Buffer.from(u8).toString('hex');\n  };\n\n  Enc.numToHex = function (d) {\n    d = d.toString(16);\n\n    if (d.length % 2) {\n      return '0' + d;\n    }\n\n    return d;\n  };\n})('undefined' !== typeof window ? window : module.exports);","map":{"version":3,"sources":["/home/neil/Desktop/Programming/LetsCodeSBISD/Forwarder/node_modules/cert-info/lib/asn1-parser.js"],"names":["exports","ASN1","Enc","PEM","ELOOPN","ELOOP","EDEEPN","EDEEP","CTYPES","VTYPES","parse","parseAsn1Helper","buf","parseAsn1","depth","eager","length","Error","index","asn1","type","lengthSize","child","iters","adjust","adjustedLen","parseInt","bufToHex","slice","parseChildren","children","console","error","JSON","stringify","_replacer","push","value","indexOf","e","len","byteLength","k","v","numToHex","data","parseBlock","str","b64","split","filter","line","test","join","der","base64ToBuf","bytes","Buffer","from","binToBuf","bin","u8","toString","d","window","module"],"mappings":"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","sourcesContent":["// Copyright 2016-2018 AJ ONeal. All rights reserved\n// https://git.coolaj86.com/coolaj86/asn1-parser.js\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n;(function (exports) {\n'use strict';\n\nif (!exports.ASN1) { exports.ASN1 = {}; }\nif (!exports.Enc) { exports.Enc = {}; }\nif (!exports.PEM) { exports.PEM = {}; }\n\nvar ASN1 = exports.ASN1;\nvar Enc = exports.Enc;\nvar PEM = exports.PEM;\n\n//\n// Parser\n//\n\n// Although I've only seen 9 max in https certificates themselves,\n// but each domain list could have up to 100\nASN1.ELOOPN = 102;\nASN1.ELOOP = \"uASN1.js Error: iterated over \" + ASN1.ELOOPN + \"+ elements (probably a malformed file)\";\n// I've seen https certificates go 29 deep\nASN1.EDEEPN = 60;\nASN1.EDEEP = \"uASN1.js Error: element nested \" + ASN1.EDEEPN + \"+ layers deep (probably a malformed file)\";\n// Container Types are Sequence 0x30, Container Array? (0xA0, 0xA1)\n// Value Types are Boolean 0x01, Integer 0x02, Null 0x05, Object ID 0x06, String 0x0C, 0x16, 0x13, 0x1e Value Array? (0x82)\n// Bit String (0x03) and Octet String (0x04) may be values or containers\n// Sometimes Bit String is used as a container (RSA Pub Spki)\nASN1.CTYPES = [ 0x30, 0x31, 0xa0, 0xa1 ];\nASN1.VTYPES = [ 0x01, 0x02, 0x05, 0x06, 0x0c, 0x82 ];\nASN1.parse = function parseAsn1Helper(buf) {\n  //var ws = '  ';\n  function parseAsn1(buf, depth, eager) {\n    if (depth.length >= ASN1.EDEEPN) { throw new Error(ASN1.EDEEP); }\n\n    var index = 2; // we know, at minimum, data starts after type (0) and lengthSize (1)\n    var asn1 = { type: buf[0], lengthSize: 0, length: buf[1] };\n    var child;\n    var iters = 0;\n    var adjust = 0;\n    var adjustedLen;\n\n    // Determine how many bytes the length uses, and what it is\n    if (0x80 & asn1.length) {\n      asn1.lengthSize = 0x7f & asn1.length;\n      // I think that buf->hex->int solves the problem of Endianness... not sure\n      asn1.length = parseInt(Enc.bufToHex(buf.slice(index, index + asn1.lengthSize)), 16);\n      index += asn1.lengthSize;\n    }\n\n    // High-order bit Integers have a leading 0x00 to signify that they are positive.\n    // Bit Streams use the first byte to signify padding, which x.509 doesn't use.\n    if (0x00 === buf[index] && (0x02 === asn1.type || 0x03 === asn1.type)) {\n      // However, 0x00 on its own is a valid number\n      if (asn1.length > 1) {\n        index += 1;\n        adjust = -1;\n      }\n    }\n    adjustedLen = asn1.length + adjust;\n\n    //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n\n    function parseChildren(eager) {\n      asn1.children = [];\n      //console.warn('1 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', 0);\n      while (iters < ASN1.ELOOPN && index < (2 + asn1.length + asn1.lengthSize)) {\n        iters += 1;\n        depth.length += 1;\n        child = parseAsn1(buf.slice(index, index + adjustedLen), depth, eager);\n        depth.length -= 1;\n        // The numbers don't match up exactly and I don't remember why...\n        // probably something with adjustedLen or some such, but the tests pass\n        index += (2 + child.lengthSize + child.length);\n        //console.warn('2 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', (2 + child.lengthSize + child.length));\n        if (index > (2 + asn1.lengthSize + asn1.length)) {\n          if (!eager) { console.error(JSON.stringify(asn1, ASN1._replacer, 2)); }\n          throw new Error(\"Parse error: child value length (\" + child.length\n            + \") is greater than remaining parent length (\" + (asn1.length - index)\n            + \" = \" + asn1.length + \" - \" + index + \")\");\n        }\n        asn1.children.push(child);\n        //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n      }\n      if (index !== (2 + asn1.lengthSize + asn1.length)) {\n        //console.warn('index:', index, 'length:', (2 + asn1.lengthSize + asn1.length));\n        throw new Error(\"premature end-of-file\");\n      }\n      if (iters >= ASN1.ELOOPN) { throw new Error(ASN1.ELOOP); }\n\n      delete asn1.value;\n      return asn1;\n    }\n\n    // Recurse into types that are _always_ containers\n    if (-1 !== ASN1.CTYPES.indexOf(asn1.type)) { return parseChildren(eager); }\n\n    // Return types that are _always_ values\n    asn1.value = buf.slice(index, index + adjustedLen);\n    if (-1 !== ASN1.VTYPES.indexOf(asn1.type)) { return asn1; }\n\n    // For ambigious / unknown types, recurse and return on failure\n    // (and return child array size to zero)\n    try { return parseChildren(true); }\n    catch(e) { asn1.children.length = 0; return asn1; }\n  }\n\n  var asn1 = parseAsn1(buf, []);\n  var len = buf.byteLength || buf.length;\n  if (len !== 2 + asn1.lengthSize + asn1.length) {\n    throw new Error(\"Length of buffer does not match length of ASN.1 sequence.\");\n  }\n  return asn1;\n};\nASN1._replacer = function (k, v) {\n  if ('type' === k) { return '0x' + Enc.numToHex(v); }\n  if (v && 'value' === k) { return '0x' + Enc.bufToHex(v.data || v); }\n  return v;\n};\n\n// don't replace the full parseBlock, if it exists\nPEM.parseBlock = PEM.parseBlock || function (str) {\n  var b64 = str.split(/\\n/).filter(function (line) {\n    return !/-----/.test(line);\n  }).join('');\n  var der = Enc.base64ToBuf(b64);\n  return { bytes: der };\n};\n\nEnc.base64ToBuf = function (b64) {\n  return Buffer.from(b64, 'base64');\n};\nEnc.binToBuf = function (bin) {\n  return Buffer.from(bin, 'binary');\n};\nEnc.bufToHex = function (u8) {\n  return Buffer.from(u8).toString('hex');\n};\nEnc.numToHex = function (d) {\n  d = d.toString(16);\n  if (d.length % 2) {\n    return '0' + d;\n  }\n  return d;\n};\n\n}('undefined' !== typeof window ? window : module.exports));\n"]},"metadata":{},"sourceType":"script"}