{"ast":null,"code":"/*global Promise*/\n'use strict';\n\nrequire('@root/encoding/bytes');\n\nvar Enc = require('@root/encoding/base64');\n\nvar Keypairs = module.exports;\n\nvar Rasha = require('./rsa.js');\n\nvar Eckles = require('./ecdsa.js');\n\nvar native = require('./lib/node/keypairs.js');\n\nKeypairs.parse = function (opts) {\n  opts = opts || {};\n  var err;\n  var jwk;\n  var pem;\n  var p;\n\n  if (!opts.key || !opts.key.kty) {\n    try {\n      jwk = JSON.parse(opts.key);\n      p = Keypairs.export({\n        jwk: jwk\n      }).catch(function (e) {\n        pem = opts.key;\n        err = new Error(\"Not a valid jwk '\" + JSON.stringify(jwk) + \"':\" + e.message);\n        err.code = 'EINVALID';\n        return Promise.reject(err);\n      }).then(function () {\n        return jwk;\n      });\n    } catch (e) {\n      p = Keypairs.import({\n        pem: opts.key\n      }).catch(function (e) {\n        err = new Error('Could not parse key (type ' + typeof opts.key + \") '\" + opts.key + \"': \" + e.message);\n        err.code = 'EPARSE';\n        return Promise.reject(err);\n      });\n    }\n  } else {\n    p = Promise.resolve(opts.key);\n  }\n\n  return p.then(function (jwk) {\n    var pubopts = JSON.parse(JSON.stringify(opts));\n    pubopts.jwk = jwk;\n    return Keypairs.publish(pubopts).then(function (pub) {\n      // 'd' happens to be the name of a private part of both RSA and ECDSA keys\n      if (opts.public || opts.publish || !jwk.d) {\n        if (opts.private) {\n          // TODO test that it can actually sign?\n          err = new Error(\"Not a private key '\" + JSON.stringify(jwk) + \"'\");\n          err.code = 'ENOTPRIVATE';\n          return Promise.reject(err);\n        }\n\n        return {\n          public: pub\n        };\n      } else {\n        return {\n          private: jwk,\n          public: pub\n        };\n      }\n    });\n  });\n};\n\nKeypairs.parseOrGenerate = function (opts) {\n  if (!opts.key) {\n    return Keypairs.generate(opts);\n  }\n\n  opts.private = true;\n  return Keypairs.parse(opts).catch(function (e) {\n    return Keypairs.generate(opts).then(function (pair) {\n      pair.parseError = e;\n      return pair;\n    });\n  });\n};\n\nKeypairs._stance = \"We take the stance that if you're knowledgeable enough to\" + \" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nKeypairs._universal = 'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\n\nKeypairs.generate = function (opts) {\n  opts = opts || {};\n  var p;\n\n  if (!opts.kty) {\n    opts.kty = opts.type;\n  }\n\n  if (!opts.kty) {\n    opts.kty = 'EC';\n  }\n\n  if (/^EC/i.test(opts.kty)) {\n    p = Eckles.generate(opts);\n  } else if (/^RSA$/i.test(opts.kty)) {\n    p = Rasha.generate(opts);\n  } else {\n    return Promise.reject(new Error(\"'\" + opts.kty + \"' is not a well-supported key type.\" + Keypairs._universal + \" Please choose 'EC', or 'RSA' if you have good reason to.\"));\n  }\n\n  return p.then(function (pair) {\n    return Keypairs.thumbprint({\n      jwk: pair.public\n    }).then(function (thumb) {\n      pair.private.kid = thumb; // maybe not the same id on the private key?\n\n      pair.public.kid = thumb;\n      return pair;\n    });\n  });\n};\n\nKeypairs.import = function (opts) {\n  return Eckles.import(opts).catch(function () {\n    return Rasha.import(opts);\n  }).then(function (jwk) {\n    return Keypairs.thumbprint({\n      jwk: jwk\n    }).then(function (thumb) {\n      jwk.kid = thumb;\n      return jwk;\n    });\n  });\n};\n\nKeypairs.export = function (opts) {\n  return Eckles.export(opts).catch(function (err) {\n    return Rasha.export(opts).catch(function () {\n      return Promise.reject(err);\n    });\n  });\n}; // XXX\n\n\nnative.export = Keypairs.export;\n/**\n * Chopping off the private parts is now part of the public API.\n * I thought it sounded a little too crude at first, but it really is the best name in every possible way.\n */\n\nKeypairs.neuter = function (opts) {\n  /** trying to find the best balance of an immutable copy with custom attributes */\n  var jwk = {};\n  Object.keys(opts.jwk).forEach(function (k) {\n    if ('undefined' === typeof opts.jwk[k]) {\n      return;\n    } // ignore RSA and EC private parts\n\n\n    if (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n      return;\n    }\n\n    jwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n  });\n  return jwk;\n};\n\nKeypairs.thumbprint = function (opts) {\n  return Promise.resolve().then(function () {\n    if (/EC/i.test(opts.jwk.kty)) {\n      return Eckles.thumbprint(opts);\n    } else {\n      return Rasha.thumbprint(opts);\n    }\n  });\n};\n\nKeypairs.publish = function (opts) {\n  if ('object' !== typeof opts.jwk || !opts.jwk.kty) {\n    throw new Error('invalid jwk: ' + JSON.stringify(opts.jwk));\n  }\n  /** returns a copy */\n\n\n  var jwk = Keypairs.neuter(opts);\n\n  if (jwk.exp) {\n    jwk.exp = setTime(jwk.exp);\n  } else {\n    if (opts.exp) {\n      jwk.exp = setTime(opts.exp);\n    } else if (opts.expiresIn) {\n      jwk.exp = Math.round(Date.now() / 1000) + opts.expiresIn;\n    } else if (opts.expiresAt) {\n      jwk.exp = opts.expiresAt;\n    }\n  }\n\n  if (!jwk.use && false !== jwk.use) {\n    jwk.use = 'sig';\n  }\n\n  if (jwk.kid) {\n    return Promise.resolve(jwk);\n  }\n\n  return Keypairs.thumbprint({\n    jwk: jwk\n  }).then(function (thumb) {\n    jwk.kid = thumb;\n    return jwk;\n  });\n}; // JWT a.k.a. JWS with Claims using Compact Serialization\n\n\nKeypairs.signJwt = function (opts) {\n  return Keypairs.thumbprint({\n    jwk: opts.jwk\n  }).then(function (thumb) {\n    var header = opts.header || {};\n    var claims = JSON.parse(JSON.stringify(opts.claims || {}));\n    header.typ = 'JWT';\n\n    if (!header.kid && !header.jwk && false !== header.kid) {\n      header.kid = thumb;\n    }\n\n    if (!header.alg && opts.alg) {\n      header.alg = opts.alg;\n    }\n\n    if (!claims.iat && (false === claims.iat || false === opts.iat)) {\n      claims.iat = undefined;\n    } else if (!claims.iat) {\n      claims.iat = Math.round(Date.now() / 1000);\n    }\n\n    if (opts.exp) {\n      claims.exp = setTime(opts.exp);\n    } else if (!claims.exp && (false === claims.exp || false === opts.exp)) {\n      claims.exp = undefined;\n    } else if (!claims.exp) {\n      throw new Error(\"opts.claims.exp should be the expiration date as seconds, human form (i.e. '1h' or '15m') or false\");\n    }\n\n    if (opts.iss) {\n      claims.iss = opts.iss;\n    }\n\n    if (!claims.iss && (false === claims.iss || false === opts.iss)) {\n      claims.iss = undefined;\n    } else if (!claims.iss) {\n      throw new Error('opts.claims.iss should be in the form of https://example.com/, a secure OIDC base url');\n    }\n\n    return Keypairs.signJws({\n      jwk: opts.jwk,\n      pem: opts.pem,\n      protected: header,\n      header: undefined,\n      payload: claims\n    }).then(function (jws) {\n      return [jws.protected, jws.payload, jws.signature].join('.');\n    });\n  });\n};\n\nKeypairs.signJws = function (opts) {\n  return Keypairs.thumbprint(opts).then(function (thumb) {\n    function alg() {\n      if (!opts.jwk) {\n        throw new Error(\"opts.jwk must exist and must declare 'typ'\");\n      }\n\n      if (opts.jwk.alg) {\n        return opts.jwk.alg;\n      }\n\n      var typ = 'RSA' === opts.jwk.kty ? 'RS' : 'ES';\n      return typ + Keypairs._getBits(opts);\n    }\n\n    function sign() {\n      var protect = opts.protected;\n      var payload = opts.payload; // Compute JWS signature\n\n      var protectedHeader = ''; // Because unprotected headers are allowed, regrettably...\n      // https://stackoverflow.com/a/46288694\n\n      if (false !== protect) {\n        if (!protect) {\n          protect = {};\n        }\n\n        if (!protect.alg) {\n          protect.alg = alg();\n        } // There's a particular request where ACME / Let's Encrypt explicitly doesn't use a kid\n        // There should be a kid unless it's `false` or there's a `jwk` (a self-signed JWS)\n\n\n        if (!protect.kid) {\n          if (false === protect.kid) {\n            protect.kid = undefined;\n          } else if (!protect.jwk) {\n            protect.kid = thumb;\n          }\n        }\n\n        protectedHeader = JSON.stringify(protect);\n      } // Trying to detect if it's a plain object (not Buffer, ArrayBuffer, Array, Uint8Array, etc)\n\n\n      if (payload && 'string' !== typeof payload && 'undefined' === typeof payload.byteLength && 'undefined' === typeof payload.buffer) {\n        payload = JSON.stringify(payload);\n      } // Converting to a buffer, even if it was just converted to a string\n\n\n      if ('string' === typeof payload) {\n        payload = Enc.strToBuf(payload);\n      }\n\n      var protected64 = Enc.strToUrlBase64(protectedHeader);\n      var payload64 = Enc.bufToUrlBase64(payload);\n      var msg = protected64 + '.' + payload64;\n      return native._sign(opts, msg).then(function (buf) {\n        var signedMsg = {\n          protected: protected64,\n          payload: payload64,\n          signature: Enc.bufToUrlBase64(buf)\n        };\n        return signedMsg;\n      });\n    }\n\n    if (opts.jwk) {\n      return sign();\n    } else {\n      return Keypairs.import({\n        pem: opts.pem\n      }).then(function (pair) {\n        opts.jwk = pair.private;\n        return sign();\n      });\n    }\n  });\n}; // TODO expose consistently\n\n\nKeypairs.sign = native._sign;\n\nKeypairs._getBits = function (opts) {\n  if (opts.alg) {\n    return opts.alg.replace(/[a-z\\-]/gi, '');\n  }\n\n  if (opts.protected && opts.protected.alg) {\n    return opts.protected.alg.replace(/[a-z\\-]/gi, '');\n  } // base64 len to byte len\n\n\n  var len = Math.floor((opts.jwk.n || '').length * 0.75); // TODO this may be a bug\n  // need to confirm that the padding is no more or less than 1 byte\n\n  if (/521/.test(opts.jwk.crv) || len >= 511) {\n    return '512';\n  } else if (/384/.test(opts.jwk.crv) || len >= 383) {\n    return '384';\n  }\n\n  return '256';\n}; // XXX\n\n\nnative._getBits = Keypairs._getBits;\n\nfunction setTime(time) {\n  if ('number' === typeof time) {\n    return time;\n  }\n\n  var t = time.match(/^(\\-?\\d+)([dhms])$/i);\n\n  if (!t || !t[0]) {\n    throw new Error(\"'\" + time + \"' should be datetime in seconds or human-readable format (i.e. 3d, 1h, 15m, 30s\");\n  }\n\n  var now = Math.round(Date.now() / 1000);\n  var num = parseInt(t[1], 10);\n  var unit = t[2];\n  var mult = 1;\n\n  switch (unit) {\n    // fancy fallthrough, what fun!\n    case 'd':\n      mult *= 24;\n\n    /*falls through*/\n\n    case 'h':\n      mult *= 60;\n\n    /*falls through*/\n\n    case 'm':\n      mult *= 60;\n\n    /*falls through*/\n\n    case 's':\n      mult *= 1;\n  }\n\n  return now + mult * num;\n}","map":{"version":3,"sources":["/home/neil/Desktop/Programming/LetsCodeSBISD/Forwarder/node_modules/@root/keypairs/keypairs.js"],"names":["require","Enc","Keypairs","module","exports","Rasha","Eckles","native","parse","opts","err","jwk","pem","p","key","kty","JSON","export","catch","e","Error","stringify","message","code","Promise","reject","then","import","resolve","pubopts","publish","pub","public","d","private","parseOrGenerate","generate","pair","parseError","_stance","_universal","type","test","thumbprint","thumb","kid","neuter","Object","keys","forEach","k","indexOf","exp","setTime","expiresIn","Math","round","Date","now","expiresAt","use","signJwt","header","claims","typ","alg","iat","undefined","iss","signJws","protected","payload","jws","signature","join","_getBits","sign","protect","protectedHeader","byteLength","buffer","strToBuf","protected64","strToUrlBase64","payload64","bufToUrlBase64","msg","_sign","buf","signedMsg","replace","len","floor","n","length","crv","time","t","match","num","parseInt","unit","mult"],"mappings":"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","sourcesContent":["/*global Promise*/\n'use strict';\n\nrequire('@root/encoding/bytes');\nvar Enc = require('@root/encoding/base64');\n\nvar Keypairs = module.exports;\nvar Rasha = require('./rsa.js');\nvar Eckles = require('./ecdsa.js');\nvar native = require('./lib/node/keypairs.js');\n\nKeypairs.parse = function (opts) {\n\topts = opts || {};\n\n\tvar err;\n\tvar jwk;\n\tvar pem;\n\tvar p;\n\n\tif (!opts.key || !opts.key.kty) {\n\t\ttry {\n\t\t\tjwk = JSON.parse(opts.key);\n\t\t\tp = Keypairs.export({ jwk: jwk })\n\t\t\t\t.catch(function (e) {\n\t\t\t\t\tpem = opts.key;\n\t\t\t\t\terr = new Error(\n\t\t\t\t\t\t\"Not a valid jwk '\" +\n\t\t\t\t\t\t\tJSON.stringify(jwk) +\n\t\t\t\t\t\t\t\"':\" +\n\t\t\t\t\t\t\te.message\n\t\t\t\t\t);\n\t\t\t\t\terr.code = 'EINVALID';\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t})\n\t\t\t\t.then(function () {\n\t\t\t\t\treturn jwk;\n\t\t\t\t});\n\t\t} catch (e) {\n\t\t\tp = Keypairs.import({ pem: opts.key }).catch(function (e) {\n\t\t\t\terr = new Error(\n\t\t\t\t\t'Could not parse key (type ' +\n\t\t\t\t\t\ttypeof opts.key +\n\t\t\t\t\t\t\") '\" +\n\t\t\t\t\t\topts.key +\n\t\t\t\t\t\t\"': \" +\n\t\t\t\t\t\te.message\n\t\t\t\t);\n\t\t\t\terr.code = 'EPARSE';\n\t\t\t\treturn Promise.reject(err);\n\t\t\t});\n\t\t}\n\t} else {\n\t\tp = Promise.resolve(opts.key);\n\t}\n\n\treturn p.then(function (jwk) {\n\t\tvar pubopts = JSON.parse(JSON.stringify(opts));\n\t\tpubopts.jwk = jwk;\n\t\treturn Keypairs.publish(pubopts).then(function (pub) {\n\t\t\t// 'd' happens to be the name of a private part of both RSA and ECDSA keys\n\t\t\tif (opts.public || opts.publish || !jwk.d) {\n\t\t\t\tif (opts.private) {\n\t\t\t\t\t// TODO test that it can actually sign?\n\t\t\t\t\terr = new Error(\n\t\t\t\t\t\t\"Not a private key '\" + JSON.stringify(jwk) + \"'\"\n\t\t\t\t\t);\n\t\t\t\t\terr.code = 'ENOTPRIVATE';\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t}\n\t\t\t\treturn { public: pub };\n\t\t\t} else {\n\t\t\t\treturn { private: jwk, public: pub };\n\t\t\t}\n\t\t});\n\t});\n};\n\nKeypairs.parseOrGenerate = function (opts) {\n\tif (!opts.key) {\n\t\treturn Keypairs.generate(opts);\n\t}\n\topts.private = true;\n\treturn Keypairs.parse(opts).catch(function (e) {\n\t\treturn Keypairs.generate(opts).then(function (pair) {\n\t\t\tpair.parseError = e;\n\t\t\treturn pair;\n\t\t});\n\t});\n};\n\nKeypairs._stance =\n\t\"We take the stance that if you're knowledgeable enough to\" +\n\t\" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nKeypairs._universal =\n\t'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\nKeypairs.generate = function (opts) {\n\topts = opts || {};\n\tvar p;\n\tif (!opts.kty) {\n\t\topts.kty = opts.type;\n\t}\n\tif (!opts.kty) {\n\t\topts.kty = 'EC';\n\t}\n\tif (/^EC/i.test(opts.kty)) {\n\t\tp = Eckles.generate(opts);\n\t} else if (/^RSA$/i.test(opts.kty)) {\n\t\tp = Rasha.generate(opts);\n\t} else {\n\t\treturn Promise.reject(\n\t\t\tnew Error(\n\t\t\t\t\"'\" +\n\t\t\t\t\topts.kty +\n\t\t\t\t\t\"' is not a well-supported key type.\" +\n\t\t\t\t\tKeypairs._universal +\n\t\t\t\t\t\" Please choose 'EC', or 'RSA' if you have good reason to.\"\n\t\t\t)\n\t\t);\n\t}\n\treturn p.then(function (pair) {\n\t\treturn Keypairs.thumbprint({ jwk: pair.public }).then(function (thumb) {\n\t\t\tpair.private.kid = thumb; // maybe not the same id on the private key?\n\t\t\tpair.public.kid = thumb;\n\t\t\treturn pair;\n\t\t});\n\t});\n};\n\nKeypairs.import = function (opts) {\n\treturn Eckles.import(opts)\n\t\t.catch(function () {\n\t\t\treturn Rasha.import(opts);\n\t\t})\n\t\t.then(function (jwk) {\n\t\t\treturn Keypairs.thumbprint({ jwk: jwk }).then(function (thumb) {\n\t\t\t\tjwk.kid = thumb;\n\t\t\t\treturn jwk;\n\t\t\t});\n\t\t});\n};\n\nKeypairs.export = function (opts) {\n\treturn Eckles.export(opts).catch(function (err) {\n\t\treturn Rasha.export(opts).catch(function () {\n\t\t\treturn Promise.reject(err);\n\t\t});\n\t});\n};\n// XXX\nnative.export = Keypairs.export;\n\n/**\n * Chopping off the private parts is now part of the public API.\n * I thought it sounded a little too crude at first, but it really is the best name in every possible way.\n */\nKeypairs.neuter = function (opts) {\n\t/** trying to find the best balance of an immutable copy with custom attributes */\n\tvar jwk = {};\n\tObject.keys(opts.jwk).forEach(function (k) {\n\t\tif ('undefined' === typeof opts.jwk[k]) {\n\t\t\treturn;\n\t\t}\n\t\t// ignore RSA and EC private parts\n\t\tif (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n\t\t\treturn;\n\t\t}\n\t\tjwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n\t});\n\treturn jwk;\n};\n\nKeypairs.thumbprint = function (opts) {\n\treturn Promise.resolve().then(function () {\n\t\tif (/EC/i.test(opts.jwk.kty)) {\n\t\t\treturn Eckles.thumbprint(opts);\n\t\t} else {\n\t\t\treturn Rasha.thumbprint(opts);\n\t\t}\n\t});\n};\n\nKeypairs.publish = function (opts) {\n\tif ('object' !== typeof opts.jwk || !opts.jwk.kty) {\n\t\tthrow new Error('invalid jwk: ' + JSON.stringify(opts.jwk));\n\t}\n\n\t/** returns a copy */\n\tvar jwk = Keypairs.neuter(opts);\n\n\tif (jwk.exp) {\n\t\tjwk.exp = setTime(jwk.exp);\n\t} else {\n\t\tif (opts.exp) {\n\t\t\tjwk.exp = setTime(opts.exp);\n\t\t} else if (opts.expiresIn) {\n\t\t\tjwk.exp = Math.round(Date.now() / 1000) + opts.expiresIn;\n\t\t} else if (opts.expiresAt) {\n\t\t\tjwk.exp = opts.expiresAt;\n\t\t}\n\t}\n\tif (!jwk.use && false !== jwk.use) {\n\t\tjwk.use = 'sig';\n\t}\n\n\tif (jwk.kid) {\n\t\treturn Promise.resolve(jwk);\n\t}\n\treturn Keypairs.thumbprint({ jwk: jwk }).then(function (thumb) {\n\t\tjwk.kid = thumb;\n\t\treturn jwk;\n\t});\n};\n\n// JWT a.k.a. JWS with Claims using Compact Serialization\nKeypairs.signJwt = function (opts) {\n\treturn Keypairs.thumbprint({ jwk: opts.jwk }).then(function (thumb) {\n\t\tvar header = opts.header || {};\n\t\tvar claims = JSON.parse(JSON.stringify(opts.claims || {}));\n\t\theader.typ = 'JWT';\n\n\t\tif (!header.kid && !header.jwk && false !== header.kid) {\n\t\t\theader.kid = thumb;\n\t\t}\n\t\tif (!header.alg && opts.alg) {\n\t\t\theader.alg = opts.alg;\n\t\t}\n\t\tif (!claims.iat && (false === claims.iat || false === opts.iat)) {\n\t\t\tclaims.iat = undefined;\n\t\t} else if (!claims.iat) {\n\t\t\tclaims.iat = Math.round(Date.now() / 1000);\n\t\t}\n\n\t\tif (opts.exp) {\n\t\t\tclaims.exp = setTime(opts.exp);\n\t\t} else if (\n\t\t\t!claims.exp &&\n\t\t\t(false === claims.exp || false === opts.exp)\n\t\t) {\n\t\t\tclaims.exp = undefined;\n\t\t} else if (!claims.exp) {\n\t\t\tthrow new Error(\n\t\t\t\t\"opts.claims.exp should be the expiration date as seconds, human form (i.e. '1h' or '15m') or false\"\n\t\t\t);\n\t\t}\n\n\t\tif (opts.iss) {\n\t\t\tclaims.iss = opts.iss;\n\t\t}\n\t\tif (!claims.iss && (false === claims.iss || false === opts.iss)) {\n\t\t\tclaims.iss = undefined;\n\t\t} else if (!claims.iss) {\n\t\t\tthrow new Error(\n\t\t\t\t'opts.claims.iss should be in the form of https://example.com/, a secure OIDC base url'\n\t\t\t);\n\t\t}\n\n\t\treturn Keypairs.signJws({\n\t\t\tjwk: opts.jwk,\n\t\t\tpem: opts.pem,\n\t\t\tprotected: header,\n\t\t\theader: undefined,\n\t\t\tpayload: claims\n\t\t}).then(function (jws) {\n\t\t\treturn [jws.protected, jws.payload, jws.signature].join('.');\n\t\t});\n\t});\n};\n\nKeypairs.signJws = function (opts) {\n\treturn Keypairs.thumbprint(opts).then(function (thumb) {\n\t\tfunction alg() {\n\t\t\tif (!opts.jwk) {\n\t\t\t\tthrow new Error(\"opts.jwk must exist and must declare 'typ'\");\n\t\t\t}\n\t\t\tif (opts.jwk.alg) {\n\t\t\t\treturn opts.jwk.alg;\n\t\t\t}\n\t\t\tvar typ = 'RSA' === opts.jwk.kty ? 'RS' : 'ES';\n\t\t\treturn typ + Keypairs._getBits(opts);\n\t\t}\n\n\t\tfunction sign() {\n\t\t\tvar protect = opts.protected;\n\t\t\tvar payload = opts.payload;\n\n\t\t\t// Compute JWS signature\n\t\t\tvar protectedHeader = '';\n\t\t\t// Because unprotected headers are allowed, regrettably...\n\t\t\t// https://stackoverflow.com/a/46288694\n\t\t\tif (false !== protect) {\n\t\t\t\tif (!protect) {\n\t\t\t\t\tprotect = {};\n\t\t\t\t}\n\t\t\t\tif (!protect.alg) {\n\t\t\t\t\tprotect.alg = alg();\n\t\t\t\t}\n\n\t\t\t\t// There's a particular request where ACME / Let's Encrypt explicitly doesn't use a kid\n\t\t\t\t// There should be a kid unless it's `false` or there's a `jwk` (a self-signed JWS)\n\t\t\t\tif (!protect.kid) {\n\t\t\t\t\tif (false === protect.kid) {\n\t\t\t\t\t\tprotect.kid = undefined;\n\t\t\t\t\t} else if (!protect.jwk) {\n\t\t\t\t\t\tprotect.kid = thumb;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprotectedHeader = JSON.stringify(protect);\n\t\t\t}\n\n\t\t\t// Trying to detect if it's a plain object (not Buffer, ArrayBuffer, Array, Uint8Array, etc)\n\t\t\tif (\n\t\t\t\tpayload &&\n\t\t\t\t'string' !== typeof payload &&\n\t\t\t\t'undefined' === typeof payload.byteLength &&\n\t\t\t\t'undefined' === typeof payload.buffer\n\t\t\t) {\n\t\t\t\tpayload = JSON.stringify(payload);\n\t\t\t}\n\t\t\t// Converting to a buffer, even if it was just converted to a string\n\t\t\tif ('string' === typeof payload) {\n\t\t\t\tpayload = Enc.strToBuf(payload);\n\t\t\t}\n\n\t\t\tvar protected64 = Enc.strToUrlBase64(protectedHeader);\n\t\t\tvar payload64 = Enc.bufToUrlBase64(payload);\n\t\t\tvar msg = protected64 + '.' + payload64;\n\n\t\t\treturn native._sign(opts, msg).then(function (buf) {\n\t\t\t\tvar signedMsg = {\n\t\t\t\t\tprotected: protected64,\n\t\t\t\t\tpayload: payload64,\n\t\t\t\t\tsignature: Enc.bufToUrlBase64(buf)\n\t\t\t\t};\n\n\t\t\t\treturn signedMsg;\n\t\t\t});\n\t\t}\n\n\t\tif (opts.jwk) {\n\t\t\treturn sign();\n\t\t} else {\n\t\t\treturn Keypairs.import({ pem: opts.pem }).then(function (pair) {\n\t\t\t\topts.jwk = pair.private;\n\t\t\t\treturn sign();\n\t\t\t});\n\t\t}\n\t});\n};\n\n// TODO expose consistently\nKeypairs.sign = native._sign;\n\nKeypairs._getBits = function (opts) {\n\tif (opts.alg) {\n\t\treturn opts.alg.replace(/[a-z\\-]/gi, '');\n\t}\n\tif (opts.protected && opts.protected.alg) {\n\t\treturn opts.protected.alg.replace(/[a-z\\-]/gi, '');\n\t}\n\t// base64 len to byte len\n\tvar len = Math.floor((opts.jwk.n || '').length * 0.75);\n\n\t// TODO this may be a bug\n\t// need to confirm that the padding is no more or less than 1 byte\n\tif (/521/.test(opts.jwk.crv) || len >= 511) {\n\t\treturn '512';\n\t} else if (/384/.test(opts.jwk.crv) || len >= 383) {\n\t\treturn '384';\n\t}\n\n\treturn '256';\n};\n// XXX\nnative._getBits = Keypairs._getBits;\n\nfunction setTime(time) {\n\tif ('number' === typeof time) {\n\t\treturn time;\n\t}\n\n\tvar t = time.match(/^(\\-?\\d+)([dhms])$/i);\n\tif (!t || !t[0]) {\n\t\tthrow new Error(\n\t\t\t\"'\" +\n\t\t\t\ttime +\n\t\t\t\t\"' should be datetime in seconds or human-readable format (i.e. 3d, 1h, 15m, 30s\"\n\t\t);\n\t}\n\n\tvar now = Math.round(Date.now() / 1000);\n\tvar num = parseInt(t[1], 10);\n\tvar unit = t[2];\n\tvar mult = 1;\n\tswitch (unit) {\n\t\t// fancy fallthrough, what fun!\n\t\tcase 'd':\n\t\t\tmult *= 24;\n\t\t/*falls through*/\n\t\tcase 'h':\n\t\t\tmult *= 60;\n\t\t/*falls through*/\n\t\tcase 'm':\n\t\t\tmult *= 60;\n\t\t/*falls through*/\n\t\tcase 's':\n\t\t\tmult *= 1;\n\t}\n\n\treturn now + mult * num;\n}\n"]},"metadata":{},"sourceType":"script"}