{"ast":null,"code":"'use strict';\n\nvar C = module.exports;\n\nvar U = require('./utils.js');\n\nvar CSR = require('@root/csr');\n\nvar Enc = require('@root/encoding');\n\nvar Keypairs = require('@root/keypairs');\n\nvar pending = {};\nvar rawPending = {}; // What the abbreviations mean\n//\n// gnlkc => greenlock\n// mconf => manager config\n// db => greenlock store instance\n// acme => instance of ACME.js\n// chs => instances of challenges\n// acc => account\n// args => site / extra options\n// Certificates\n\nC._getOrOrder = function (gnlck, mconf, db, acme, chs, acc, args) {\n  var email = args.subscriberEmail || mconf.subscriberEmail;\n  var id = args.altnames.slice(0).sort().join(' ');\n\n  if (pending[id]) {\n    return pending[id];\n  }\n\n  pending[id] = C._rawGetOrOrder(gnlck, mconf, db, acme, chs, acc, email, args).then(function (pems) {\n    delete pending[id];\n    return pems;\n  }).catch(function (err) {\n    delete pending[id];\n    throw err;\n  });\n  return pending[id];\n}; // Certificates\n\n\nC._rawGetOrOrder = function (gnlck, mconf, db, acme, chs, acc, email, args) {\n  return C._check(gnlck, mconf, db, args).then(function (pems) {\n    // Nice and fresh? We're done!\n    if (pems) {\n      if (!C._isStale(gnlck, mconf, args, pems)) {\n        // return existing unexpired (although potentially stale) certificates when available\n        // there will be an additional .renewing property if the certs are being asynchronously renewed\n        //pems._type = 'current';\n        return pems;\n      }\n    } // We're either starting fresh or freshening up...\n\n\n    var p = C._rawOrder(gnlck, mconf, db, acme, chs, acc, email, args);\n\n    var evname = pems ? 'cert_renewal' : 'cert_issue';\n    p.then(function (newPems) {\n      // notify in the background\n      var renewAt = C._renewWithStagger(gnlck, mconf, args, newPems);\n\n      gnlck._notify(evname, {\n        renewAt: renewAt,\n        subject: args.subject,\n        altnames: args.altnames\n      });\n\n      gnlck._notify('_cert_issue', {\n        renewAt: renewAt,\n        subject: args.subject,\n        altnames: args.altnames,\n        pems: newPems\n      });\n    }).catch(function (err) {\n      if (!err.context) {\n        err.context = evname;\n      }\n\n      err.subject = args.subject;\n      err.altnames = args.altnames;\n\n      gnlck._notify('error', err);\n    }); // No choice but to hang tight and wait for it\n\n    if (!pems || pems.renewAt < Date.now() - 24 * 60 * 60 * 1000 || pems.expiresAt <= Date.now() + 24 * 60 * 60 * 1000) {\n      return p;\n    } // Wait it out\n    // TODO should we call this waitForRenewal?\n\n\n    if (args.waitForRenewal) {\n      return p;\n    } // Let the certs renew in the background\n\n\n    return pems;\n  });\n}; // we have another promise here because it the optional renewal\n// may resolve in a different stack than the returned pems\n\n\nC._rawOrder = function (gnlck, mconf, db, acme, chs, acc, email, args) {\n  var id = args.altnames.slice(0).sort().join(' ');\n\n  if (rawPending[id]) {\n    return rawPending[id];\n  }\n\n  var keyType = args.serverKeyType || mconf.serverKeyType;\n  var query = {\n    subject: args.subject,\n    certificate: args.certificate || {},\n    directoryUrl: args.directoryUrl || mconf.directoryUrl || gnlck._defaults.directoryUrl\n  };\n  rawPending[id] = U._getOrCreateKeypair(db, args.subject, query, keyType).then(function (kresult) {\n    var serverKeypair = kresult.keypair;\n    var domains = args.altnames.slice(0);\n    return CSR.csr({\n      jwk: serverKeypair.privateKeyJwk || serverKeypair.private,\n      domains: domains,\n      encoding: 'der'\n    }).then(function (csrDer) {\n      // TODO let CSR support 'urlBase64' ?\n      return Enc.bufToUrlBase64(csrDer);\n    }).then(function (csr) {\n      function notify(ev, opts) {\n        gnlck._notify(ev, opts);\n      }\n\n      var certReq = {\n        debug: args.debug || gnlck._defaults.debug,\n        challenges: chs,\n        account: acc,\n        // only used if accounts.key.kid exists\n        accountKey: acc.keypair.privateKeyJwk || acc.keypair.private,\n        keypair: acc.keypair,\n        // TODO\n        csr: csr,\n        domains: domains,\n        // because ACME.js v3 uses `domains` still, actually\n        onChallengeStatus: notify,\n        notify: notify // TODO\n        // TODO handle this in acme-v2\n        //subject: args.subject,\n        //altnames: args.altnames.slice(0),\n\n      };\n      return acme.certificates.create(certReq).then(U._attachCertInfo);\n    }).then(function (pems) {\n      if (kresult.exists) {\n        return pems;\n      }\n\n      query.keypair = serverKeypair;\n      return db.setKeypair(query, serverKeypair).then(function () {\n        return pems;\n      });\n    });\n  }).then(function (pems) {\n    // TODO put this in the docs\n    // { cert, chain, privkey, subject, altnames, issuedAt, expiresAt }\n    // Note: the query has been updated\n    query.pems = pems;\n    return db.set(query);\n  }).then(function () {\n    return C._check(gnlck, mconf, db, args);\n  }).then(function (bundle) {\n    // TODO notify Manager\n    delete rawPending[id];\n    return bundle;\n  }).catch(function (err) {\n    // Todo notify manager\n    delete rawPending[id];\n    throw err;\n  });\n  return rawPending[id];\n}; // returns pems, if they exist\n\n\nC._check = function (gnlck, mconf, db, args) {\n  var query = {\n    subject: args.subject,\n    // may contain certificate.id\n    certificate: args.certificate,\n    directoryUrl: args.directoryUrl || mconf.directoryUrl || gnlck._defaults.directoryUrl\n  };\n  return db.check(query).then(function (pems) {\n    if (!pems) {\n      return null;\n    }\n\n    pems = U._attachCertInfo(pems); // For eager management\n\n    if (args.subject && !U._certHasDomain(pems, args.subject)) {\n      // TODO report error, but continue the process as with no cert\n      return null;\n    } // For lazy SNI requests\n\n\n    if (args.domain && !U._certHasDomain(pems, args.domain)) {\n      // TODO report error, but continue the process as with no cert\n      return null;\n    }\n\n    return U._getKeypair(db, args.subject, query).then(function (keypair) {\n      return Keypairs.export({\n        jwk: keypair.privateKeyJwk || keypair.private,\n        encoding: 'pem'\n      }).then(function (pem) {\n        pems.privkey = pem;\n        return pems;\n      });\n    }).catch(function () {\n      // TODO report error, but continue the process as with no cert\n      return null;\n    });\n  });\n}; // Certificates\n\n\nC._isStale = function (gnlck, mconf, args, pems) {\n  if (args.duplicate) {\n    return true;\n  }\n\n  var renewAt = C._renewableAt(gnlck, mconf, args, pems);\n\n  if (Date.now() >= renewAt) {\n    return true;\n  }\n\n  return false;\n};\n\nC._renewWithStagger = function (gnlck, mconf, args, pems) {\n  var renewOffset = C._renewOffset(gnlck, mconf, args, pems);\n\n  var renewStagger;\n\n  try {\n    renewStagger = U._parseDuration(args.renewStagger || mconf.renewStagger || 0);\n  } catch (e) {\n    renewStagger = U._parseDuration(args.renewStagger || mconf.renewStagger);\n  } // TODO check this beforehand\n\n\n  if (!args.force && renewStagger / renewOffset >= 0.5) {\n    renewStagger = renewOffset * 0.1;\n  }\n\n  if (renewOffset > 0) {\n    // stagger forward, away from issued at\n    return Math.round(pems.issuedAt + renewOffset + Math.random() * renewStagger);\n  } // stagger backward, toward issued at\n\n\n  return Math.round(pems.expiresAt + renewOffset - Math.random() * renewStagger);\n};\n\nC._renewOffset = function (gnlck, mconf, args\n/*, pems*/\n) {\n  var renewOffset = U._parseDuration(args.renewOffset || mconf.renewOffset || 0);\n\n  var week = 1000 * 60 * 60 * 24 * 6;\n\n  if (!args.force && Math.abs(renewOffset) < week) {\n    throw new Error('developer error: `renewOffset` should always be at least a week, use `force` to not safety-check renewOffset');\n  }\n\n  return renewOffset;\n};\n\nC._renewableAt = function (gnlck, mconf, args, pems) {\n  if (args.renewAt) {\n    return args.renewAt;\n  }\n\n  var renewOffset = C._renewOffset(gnlck, mconf, args, pems);\n\n  if (renewOffset > 0) {\n    return pems.issuedAt + renewOffset;\n  }\n\n  return pems.expiresAt + renewOffset;\n};","map":{"version":3,"sources":["/home/neil/Desktop/Programming/LetsCodeSBISD/Forwarder/node_modules/@root/greenlock/certificates.js"],"names":["C","module","exports","U","require","CSR","Enc","Keypairs","pending","rawPending","_getOrOrder","gnlck","mconf","db","acme","chs","acc","args","email","subscriberEmail","id","altnames","slice","sort","join","_rawGetOrOrder","then","pems","catch","err","_check","_isStale","p","_rawOrder","evname","newPems","renewAt","_renewWithStagger","_notify","subject","context","Date","now","expiresAt","waitForRenewal","keyType","serverKeyType","query","certificate","directoryUrl","_defaults","_getOrCreateKeypair","kresult","serverKeypair","keypair","domains","csr","jwk","privateKeyJwk","private","encoding","csrDer","bufToUrlBase64","notify","ev","opts","certReq","debug","challenges","account","accountKey","onChallengeStatus","certificates","create","_attachCertInfo","exists","setKeypair","set","bundle","check","_certHasDomain","domain","_getKeypair","export","pem","privkey","duplicate","_renewableAt","renewOffset","_renewOffset","renewStagger","_parseDuration","e","force","Math","round","issuedAt","random","week","abs","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nvar C = module.exports;\nvar U = require('./utils.js');\nvar CSR = require('@root/csr');\nvar Enc = require('@root/encoding');\nvar Keypairs = require('@root/keypairs');\n\nvar pending = {};\nvar rawPending = {};\n\n// What the abbreviations mean\n//\n// gnlkc => greenlock\n// mconf => manager config\n// db => greenlock store instance\n// acme => instance of ACME.js\n// chs => instances of challenges\n// acc => account\n// args => site / extra options\n\n// Certificates\nC._getOrOrder = function(gnlck, mconf, db, acme, chs, acc, args) {\n    var email = args.subscriberEmail || mconf.subscriberEmail;\n\n    var id = args.altnames\n        .slice(0)\n        .sort()\n        .join(' ');\n    if (pending[id]) {\n        return pending[id];\n    }\n\n    pending[id] = C._rawGetOrOrder(\n        gnlck,\n        mconf,\n        db,\n        acme,\n        chs,\n        acc,\n        email,\n        args\n    )\n        .then(function(pems) {\n            delete pending[id];\n            return pems;\n        })\n        .catch(function(err) {\n            delete pending[id];\n            throw err;\n        });\n\n    return pending[id];\n};\n\n// Certificates\nC._rawGetOrOrder = function(gnlck, mconf, db, acme, chs, acc, email, args) {\n    return C._check(gnlck, mconf, db, args).then(function(pems) {\n        // Nice and fresh? We're done!\n        if (pems) {\n            if (!C._isStale(gnlck, mconf, args, pems)) {\n                // return existing unexpired (although potentially stale) certificates when available\n                // there will be an additional .renewing property if the certs are being asynchronously renewed\n                //pems._type = 'current';\n                return pems;\n            }\n        }\n\n        // We're either starting fresh or freshening up...\n        var p = C._rawOrder(gnlck, mconf, db, acme, chs, acc, email, args);\n        var evname = pems ? 'cert_renewal' : 'cert_issue';\n        p.then(function(newPems) {\n            // notify in the background\n            var renewAt = C._renewWithStagger(gnlck, mconf, args, newPems);\n            gnlck._notify(evname, {\n                renewAt: renewAt,\n                subject: args.subject,\n                altnames: args.altnames\n            });\n            gnlck._notify('_cert_issue', {\n                renewAt: renewAt,\n                subject: args.subject,\n                altnames: args.altnames,\n                pems: newPems\n            });\n        }).catch(function(err) {\n            if (!err.context) {\n                err.context = evname;\n            }\n            err.subject = args.subject;\n            err.altnames = args.altnames;\n            gnlck._notify('error', err);\n        });\n\n        // No choice but to hang tight and wait for it\n        if (\n            !pems ||\n            pems.renewAt < Date.now() - 24 * 60 * 60 * 1000 ||\n            pems.expiresAt <= Date.now() + 24 * 60 * 60 * 1000\n        ) {\n            return p;\n        }\n\n        // Wait it out\n        // TODO should we call this waitForRenewal?\n        if (args.waitForRenewal) {\n            return p;\n        }\n\n        // Let the certs renew in the background\n        return pems;\n    });\n};\n\n// we have another promise here because it the optional renewal\n// may resolve in a different stack than the returned pems\nC._rawOrder = function(gnlck, mconf, db, acme, chs, acc, email, args) {\n    var id = args.altnames\n        .slice(0)\n        .sort()\n        .join(' ');\n    if (rawPending[id]) {\n        return rawPending[id];\n    }\n\n    var keyType = args.serverKeyType || mconf.serverKeyType;\n    var query = {\n        subject: args.subject,\n        certificate: args.certificate || {},\n        directoryUrl:\n            args.directoryUrl ||\n            mconf.directoryUrl ||\n            gnlck._defaults.directoryUrl\n    };\n    rawPending[id] = U._getOrCreateKeypair(db, args.subject, query, keyType)\n        .then(function(kresult) {\n            var serverKeypair = kresult.keypair;\n            var domains = args.altnames.slice(0);\n\n            return CSR.csr({\n                jwk: serverKeypair.privateKeyJwk || serverKeypair.private,\n                domains: domains,\n                encoding: 'der'\n            })\n                .then(function(csrDer) {\n                    // TODO let CSR support 'urlBase64' ?\n                    return Enc.bufToUrlBase64(csrDer);\n                })\n                .then(function(csr) {\n                    function notify(ev, opts) {\n                        gnlck._notify(ev, opts);\n                    }\n                    var certReq = {\n                        debug: args.debug || gnlck._defaults.debug,\n\n                        challenges: chs,\n                        account: acc, // only used if accounts.key.kid exists\n                        accountKey:\n                            acc.keypair.privateKeyJwk || acc.keypair.private,\n                        keypair: acc.keypair, // TODO\n                        csr: csr,\n                        domains: domains, // because ACME.js v3 uses `domains` still, actually\n                        onChallengeStatus: notify,\n                        notify: notify // TODO\n\n                        // TODO handle this in acme-v2\n                        //subject: args.subject,\n                        //altnames: args.altnames.slice(0),\n                    };\n                    return acme.certificates\n                        .create(certReq)\n                        .then(U._attachCertInfo);\n                })\n                .then(function(pems) {\n                    if (kresult.exists) {\n                        return pems;\n                    }\n                    query.keypair = serverKeypair;\n                    return db.setKeypair(query, serverKeypair).then(function() {\n                        return pems;\n                    });\n                });\n        })\n        .then(function(pems) {\n            // TODO put this in the docs\n            // { cert, chain, privkey, subject, altnames, issuedAt, expiresAt }\n            // Note: the query has been updated\n            query.pems = pems;\n            return db.set(query);\n        })\n        .then(function() {\n            return C._check(gnlck, mconf, db, args);\n        })\n        .then(function(bundle) {\n            // TODO notify Manager\n            delete rawPending[id];\n            return bundle;\n        })\n        .catch(function(err) {\n            // Todo notify manager\n            delete rawPending[id];\n            throw err;\n        });\n\n    return rawPending[id];\n};\n\n// returns pems, if they exist\nC._check = function(gnlck, mconf, db, args) {\n    var query = {\n        subject: args.subject,\n        // may contain certificate.id\n        certificate: args.certificate,\n        directoryUrl:\n            args.directoryUrl ||\n            mconf.directoryUrl ||\n            gnlck._defaults.directoryUrl\n    };\n    return db.check(query).then(function(pems) {\n        if (!pems) {\n            return null;\n        }\n\n        pems = U._attachCertInfo(pems);\n\n        // For eager management\n        if (args.subject && !U._certHasDomain(pems, args.subject)) {\n            // TODO report error, but continue the process as with no cert\n            return null;\n        }\n\n        // For lazy SNI requests\n        if (args.domain && !U._certHasDomain(pems, args.domain)) {\n            // TODO report error, but continue the process as with no cert\n            return null;\n        }\n\n        return U._getKeypair(db, args.subject, query)\n            .then(function(keypair) {\n                return Keypairs.export({\n                    jwk: keypair.privateKeyJwk || keypair.private,\n                    encoding: 'pem'\n                }).then(function(pem) {\n                    pems.privkey = pem;\n                    return pems;\n                });\n            })\n            .catch(function() {\n                // TODO report error, but continue the process as with no cert\n                return null;\n            });\n    });\n};\n\n// Certificates\nC._isStale = function(gnlck, mconf, args, pems) {\n    if (args.duplicate) {\n        return true;\n    }\n\n    var renewAt = C._renewableAt(gnlck, mconf, args, pems);\n\n    if (Date.now() >= renewAt) {\n        return true;\n    }\n\n    return false;\n};\n\nC._renewWithStagger = function(gnlck, mconf, args, pems) {\n    var renewOffset = C._renewOffset(gnlck, mconf, args, pems);\n    var renewStagger;\n    try {\n        renewStagger = U._parseDuration(\n            args.renewStagger || mconf.renewStagger || 0\n        );\n    } catch (e) {\n        renewStagger = U._parseDuration(\n            args.renewStagger || mconf.renewStagger\n        );\n    }\n\n    // TODO check this beforehand\n    if (!args.force && renewStagger / renewOffset >= 0.5) {\n        renewStagger = renewOffset * 0.1;\n    }\n\n    if (renewOffset > 0) {\n        // stagger forward, away from issued at\n        return Math.round(\n            pems.issuedAt + renewOffset + Math.random() * renewStagger\n        );\n    }\n\n    // stagger backward, toward issued at\n    return Math.round(\n        pems.expiresAt + renewOffset - Math.random() * renewStagger\n    );\n};\nC._renewOffset = function(gnlck, mconf, args /*, pems*/) {\n    var renewOffset = U._parseDuration(\n        args.renewOffset || mconf.renewOffset || 0\n    );\n    var week = 1000 * 60 * 60 * 24 * 6;\n    if (!args.force && Math.abs(renewOffset) < week) {\n        throw new Error(\n            'developer error: `renewOffset` should always be at least a week, use `force` to not safety-check renewOffset'\n        );\n    }\n    return renewOffset;\n};\nC._renewableAt = function(gnlck, mconf, args, pems) {\n    if (args.renewAt) {\n        return args.renewAt;\n    }\n\n    var renewOffset = C._renewOffset(gnlck, mconf, args, pems);\n\n    if (renewOffset > 0) {\n        return pems.issuedAt + renewOffset;\n    }\n\n    return pems.expiresAt + renewOffset;\n};\n"]},"metadata":{},"sourceType":"script"}